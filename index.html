<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Visualizing F1 Driver's Success Across Nations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
        .header-bar {
            background-color: #E10500;
            height: 50px;
            width: 100%;
        }

        .header-bar img {
            height: 35px;
            margin: 7px 15px;
            vertical-align: middle;
        }

        .map {
            margin-top: 20px;
            display: flex;
            flex-direction: row;
        }

        .title {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .title h3 {
            margin: 0 15px;
            font-size: 24px;
        }

        .title h5 {
            margin: 0 15px;
            font-size: 24px;
        }

        .flex-column {
            display: flex;
            flex-direction: column;
        }

        .flex-row {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }

        .flag-icon {
            height: 40px;
            width: auto;
        }

        #legend {
            padding-left: 40px;
            padding-top: 550px;
        }

        #choropleth {
            border: solid;
            border-color: #E10500;
            border-width: 2px;
        }

        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }
    </style>
</head>
<body>

<div class="header-bar">
    <img src="images/f1_logo.png" alt="F1 Logo">
</div>

<div class="map">
    <div class="flex-column">
        <div class="title">
            <img src="images/flag.png" alt="Checkered Flag" class="flag-icon">
            <h3>Ready? Set? Go!</h3>
            <h5>Which Countries have the Best F1 Drivers?</h5>
            <img src="images/flag.png" alt="Checkered Flag" class="flag-icon">
        </div>
        <svg id="choropleth" height="700" width="1000"></svg>
    </div>
    <svg id="legend" width="200" height="300"></svg>
</div>

<div id="buttons-bar"></div>

<div class = "flex-row">
<div>
    <h3>Win Rate for Each Country Across Time</h3>
    <svg id="barchart" height="500" width="800" style="margin-top:50px"></svg>
</div>
<div class = "flex-column">
    <div>
        <h3>Frequency Histogram of the Number of Years a Driver is Active</h3>
        <svg id="barchart_year_active" height="300" width="500"></svg>
    </div>
    <div>
        <h3>FastLap Rate for Each Country Across Time</h3>
        <svg id = "barchart_fast_lap" height="300" width="500"></svg>
    </div>
</div>
</div>
</div>
<script>
    // Mapping country codes to full country names
    const countryName = {
        "ITA": "Italy",
        "ARG": "Argentina",
        "GBR": "United Kingdom",
        "AUS": "Australia",
        "USA": "United States",
        "NZL": "New Zealand",
        "AUT": "Austria",
        "BRA": "Brazil",
        "RSA": "South Africa",
        "FIN": "Finland",
        "FRA": "France",
        "GER": "Germany",
        "ESP": "Spain",
        "CAN": "Canada",
        "NED": "Netherlands",
    };

    const svg = d3.select("#choropleth");
    const width = +svg.attr("width");
    const height = +svg.attr("height");

    let mapWidth = svg.attr("width");
    let mapHeight = svg.attr("height");
    let viewport = svg.append("g");

    const projection = d3.geoMercator()
        .translate([width / 2, (height / 2) + 110]);

    const path = d3.geoPath().projection(projection);

    async function loadData() {
        const worldData = await d3.json("data/world_map.json");
        const championData = await d3.csv("data/merged_dataset_F1.csv", d3.autoType);

        championData.forEach(d => {
            d.Nationality = countryName[d.Nationality] || d.Nationality;
        });

        const country_points = {};
        championData.forEach(d => {
            if (country_points[d.Nationality]) {
                country_points[d.Nationality] += d.Points;
            } else {
                country_points[d.Nationality] = d.Points;
            }
        });

        const pointsArray = Object.values(country_points);
        const colorScale = d3.scaleQuantile()
            .domain(pointsArray)
            .range(["#D5D7E5", "#C4A5C4", "#9986AD", "#5B6887", "#46324F"]);

        let mouseOver = function (event, d) {
            d3.selectAll(".country")
                .style("opacity", .9);
            d3.select(this)
                .style("opacity", 1)
                .style("stroke", "black");
        };

        let mouseLeave = function (event, d) {
            d3.selectAll(".country")
                .style("opacity", 1);
            d3.select(this)
                .style("stroke", "grey");
        };

        var zoom = d3.zoom()
            .scaleExtent([1, 20])
            .translateExtent([[-50, -50], [mapWidth + 50, mapHeight + 50]])
            .on("zoom", mapZoomed);

        svg.call(zoom);

        function mapZoomed({ transform }) {
            viewport.attr("transform", transform.toString());
            viewport.selectAll(".country")
                .style("stroke-width", .5 / transform.k);

            if (transform.k <= 1) {
                viewport.selectAll(".country").attr("visibility", "visible");
            }
        }

        function clicked(event, d) {
            let bounds = path.bounds(d);
            let dx = bounds[1][0] - bounds[0][0];
            let dy = bounds[1][1] - bounds[0][1];
            let x = (bounds[0][0] + bounds[1][0]) / 2;
            let y = (bounds[0][1] + bounds[1][1]) / 2;
            let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dx / mapWidth, dy / mapHeight)));
            let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];

            svg.transition().duration(1000).call(
                zoom.transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );

            viewport.selectAll(".country")
                .attr("visibility", d2 => (d === d2 ? "visible" : "hidden"));
        }

        viewport.selectAll(".country")
            .data(worldData.features)
            .join("path")
            .attr("class", "country")
            .attr("d", path)
            .attr("stroke", "grey")
            .attr("stroke-width", .2)
            .attr("fill", d => {
                const countryName = d.properties.name_long;
                const points = country_points[countryName];
                return points !== undefined ? colorScale(points) : "#E0E0E0";
            })
            .on("mouseover", mouseOver)
            .on("mouseleave", mouseLeave)
            .on("click", clicked);

        const legend = d3.select("#legend");
        const thresholds = [1].concat(colorScale.quantiles());

        colorScale.range().forEach((color, i) => {
            legend.append("rect")
                .attr("x", 10)
                .attr("y", i * 25)
                .attr("width", 20)
                .attr("height", 20)
                .attr("fill", color);

            const min = Math.round(thresholds[i]);
            const max = Math.round(thresholds[i + 1] || d3.max(pointsArray));
            legend.append("text")
                .attr("x", 40)
                .attr("y", i * 25 + 15)
                .text(`${min} - ${max}`);
        });
        

        // Part II

        // Create the Buttons for different Years
        let myDictionary = {
            "1950-1963": [],
            "1964-1977": [],
            "1978-1991": [],
            "1992-2005": [],
            "2006-2020": [],
            "All Years": []
        };

        function assignDataToRanges(data, ranges) {
            data.forEach(v => {
                        for (let range in ranges) {
                            if(range != "All Years"){
                                const [startYear, endYear] = range.split("-");
                            if (v.Year >= parseInt(startYear) && v.Year <= parseInt(endYear)) {
                                ranges[range].push(v);
                            }
                            }
                            else{
                                ranges[range].push(v);
                            }
                        }
                    });
                };
        assignDataToRanges(championData, myDictionary);
        //New: Interactive Bar Chart
        var svg_bar = d3.select("svg#barchart");
        var width_bar = svg_bar.attr("width");
        var height_bar = svg_bar.attr("height");
        var margin_bar = { top: 10, right: 10, bottom: 50, left: 50 };
        var chartWidth_bar = width_bar - margin_bar.left - margin_bar.right;
        var chartHeight_bar = height_bar - margin_bar.top - margin_bar.bottom;

        let annotations = svg_bar.append("g").attr("id", "annotations");
        let chartArea = svg_bar.append("g").attr("id", "points")
            .attr("transform", `translate(${margin_bar.left},${margin_bar.top})`);

        const percentScale = d3.scaleLinear().domain([0, 1]).range([chartHeight_bar, 0]);
        let leftAxis = d3.axisLeft(percentScale).tickFormat(d3.format('.0%'));
        let leftGridlines = d3.axisLeft(percentScale)
                    .tickSize(-chartWidth_bar - 10)
                    .tickFormat("")
        annotations.append("g")
                    .attr("class", "y axis")
                    .attr("transform", `translate(${margin_bar.left - 10},${margin_bar.top})`)
                    .call(leftAxis)
        annotations.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform", `translate(${margin_bar.left - 10},${margin_bar.top})`)
                    .call(leftGridlines)

        // The x axis is going to be changing because genres change - we need to store and adjust it
        // We leave xAxis as a blank axis for now, but keep the reference outside of the function so we can rewrite it
            
            
        let bottomAxis = d3.axisBottom();
        let bottomAxisG = annotations.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(${margin_bar.left},${chartHeight_bar + margin_bar.top + 10})`);


        function updateBarsAnimated(yearKey) {

            const data = yearKey;

            const genres = d3.map(data, d => d.Nationality);
            const genreScale = d3.scaleBand().domain(genres).range([0, chartWidth_bar])
                .padding(0.05);

            // Update and animate axes
            bottomAxis.scale(genreScale)
            bottomAxisG.transition().call(bottomAxis);

            chartArea.selectAll('rect.bar')
                .data(data)
                .join(enter => enter.append('rect')
                    .attr('class', 'bar')
                    .attr("fill", "#E10500")
                    .attr("x", d => genreScale(d.Nationality))
                    .attr("y", d => percentScale(d.Win_Rate))
                    .attr("height", d => percentScale(0) - percentScale(d.Win_Rate))
                    .attr("width", genreScale.bandwidth())
                    .attr("opacity", 0) // Set opacity low, then animate to 1 to make them fade in
                    .call(enter => enter.transition()
                        .attr('opacity', 1)),
                    update => update.call(update => update.transition()  // Animate resizing and movement
                        .attr("fill", "#E10500")
                        .attr("x", d => genreScale(d.Nationality))
                        .attr("y", d => percentScale(d.Win_Rate))
                        .attr("height", d => percentScale(0) - percentScale(d.Win_Rate))
                        .attr("width", genreScale.bandwidth())),
                    exit => exit.call(exit => exit.transition().attr('opacity', 0).remove())); // Animate opacity to fade out
        };



        // Years Active

        var svg_bar_yr = d3.select("svg#barchart_year_active");
        var width_bar_yr = svg_bar_yr.attr("width");
        var height_bar_yr = svg_bar_yr.attr("height");
        var chartWidth_bar_yr = width_bar_yr - margin_bar.left - margin_bar.right;
        var chartHeight_bar_yr = height_bar_yr - margin_bar.top - margin_bar.bottom;

        // Group for chart elements
        var annotations_yr = svg_bar_yr.append("g").attr("id", "annotations_yr");
        var chartArea_yr = svg_bar_yr.append("g").attr("id", "points_yr")
            .attr("transform", `translate(${margin_bar.left},${margin_bar.top})`);

        var xScale = d3.scaleLinear()
            .domain([0,20])
            .range([0, chartWidth_bar_yr]);
        // Axes groups
        var yScale = d3.scaleLinear()
                        .domain([0,20])
                        .range([chartHeight_bar_yr, 0]);

        let bottomAxis_yr = d3.axisBottom(xScale);
        let bottomAxisG_yr = annotations_yr.append("g")
            .attr("class", "x axis")
            .attr("transform", `translate(${margin_bar.left},${chartHeight_bar_yr + margin_bar.top + 10})`)
            .call(bottomAxis_yr);

        let leftAxis_yr = d3.axisLeft(yScale);
        let leftAxisG_yr = annotations_yr.append("g")
            .attr("class", "y axis")
            .attr("transform", `translate(${margin_bar.left - 10},${margin_bar.top})`)
            .call(leftAxis_yr);

        let yGridlines_yr = d3.axisLeft(yScale)
            .tickSize(-chartWidth_bar_yr)
            .tickFormat(""); // Hide gridline labels

        annotations_yr.append("g")
            .attr("class", "y gridlines")
            .attr("transform", `translate(${margin_bar.left - 10},${margin_bar.top})`)
            .call(yGridlines_yr);
            
        // x-axis text
        annotations_yr.append("text")
            .attr("class", "x axis-label")
            .attr("text-anchor", "middle")
            .attr("x", margin_bar.left + chartWidth_bar_yr / 2)
            .attr("y", chartHeight_bar_yr + margin_bar.top + 50) 
            .text("Years Active"); 

        // y-axis text
        annotations_yr.append("text")
            .attr("class", "y axis-label")
            .attr("text-anchor", "middle")
            .attr("x", -chartHeight_bar_yr / 2)
            .attr("y", margin_bar.left - 34)
            .attr("transform", "rotate(-90)")
            .text("Frequency");
    
        function updateBarsAnimatedYearActive(yearKey) {
            const data = yearKey;

            xScale.domain([0, d3.max(data, d => d.Years_Active)]);  // Adjust domain based on years active range
            const histogram = d3.histogram()
                .value(d => d.Years_Active)
                .domain(xScale.domain())
                .thresholds(xScale.ticks(Math.sqrt(data.length)));

            var bins = histogram(data);
            
            yScale.domain([0, d3.max(bins, d => d.length)]);  // Max frequency of any bin

            bottomAxisG_yr.transition().duration(500).call(bottomAxis_yr);
            leftAxisG_yr.transition().duration(500).call(leftAxis_yr);

            console.log(bins);
            chartArea_yr.selectAll('rect.bar')
                    .data(bins) // Update data with bins
                    .join(
                        enter => enter.append('rect')
                            .attr('class', 'bar')
                            .attr("fill", "steelblue") // Set bar color
                            .attr("x", d => xScale(d.x0)) // Set bar position based on x0 (lower bound)
                            .attr("y", chartHeight_bar_yr) // Start from the bottom
                            .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1)) // Set bar width based on bin range
                            .attr("height", 0)
                            .attr("opacity", 0)
                            .call(enter => enter.transition()
                                .attr("y", d => yScale(d.length))
                                .attr("height", d => chartHeight_bar_yr - yScale(d.length))
                                .attr('opacity', 1)),
                        update => update.call(update => update.transition()  // Animate resizing and movement
                            .duration(500)
                            .attr("x", d => xScale(d.x0)) // Set bar position based on x0 (lower bound)
                            .attr("y", d => yScale(d.length)) // Set bar position based on number of elements (length)
                            .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1)) // Set bar width based on bin range
                            .attr("height", d => chartHeight_bar_yr - yScale(d.length)) // Set bar height based on number of elements (length)
                        ),
                        exit => exit.call(exit => exit.transition().attr('opacity', 0).remove()) // Animate opacity to fade out on exit
        );
        };



        // Fastest Lap Rate
        var svg_fast_lap = d3.select("svg#barchart_fast_lap");
        var width_bar_lap = svg_fast_lap.attr("width");
        var height_bar_lap = svg_fast_lap.attr("height");
        var chartWidth_bar_lap = width_bar_lap - margin_bar.left - margin_bar.right;
        var chartHeight_bar_lap = height_bar_lap - margin_bar.top - margin_bar.bottom;

        let annotations_lap = svg_fast_lap.append("g").attr("id", "annotations_lap");
        let chartArea_lap = svg_fast_lap.append("g").attr("id", "points_lap")
            .attr("transform", `translate(${margin_bar.left},${margin_bar.top})`);

        const percentScale_lap = d3.scaleLinear().domain([0, 1]).range([chartHeight_bar_lap, 0]);
        let leftAxis_lap = d3.axisLeft(percentScale_lap).tickFormat(d3.format('.0%'));
        let leftGridlines_lap = d3.axisLeft(percentScale_lap)
                                    .tickSize(-chartWidth_bar_lap - 10)
                                    .tickFormat("");
        annotations_lap.append("g")
                    .attr("class", "y axis")
                    .attr("transform", `translate(${margin_bar.left - 10},${margin_bar.top})`)
                    .call(leftAxis_lap);
        annotations_lap.append("g")
                    .attr("class", "y gridlines")
                    .attr("transform", `translate(${margin_bar.left - 10},${margin_bar.top})`)
                    .call(leftGridlines_lap);

        let genreScale_lap = d3.scaleBand().range([0, chartWidth_bar_lap]);// d3.scaleBand().range([0, chartWidth_bar_lap]); // Placeholder for the x scale
        let bottomAxis_lap = d3.axisBottom(genreScale_lap);
        let bottomAxisG_lap = annotations_lap.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(${margin_bar.left},${chartHeight_bar_lap + margin_bar.top + 10})`)
                    .call(bottomAxis_lap);

        // x-axis text
        annotations_lap.append("text")
            .attr("class", "x axis-label")
            .attr("text-anchor", "middle")
            .attr("x", margin_bar.left + chartWidth_bar_lap / 2)
            .attr("y", chartHeight_bar_lap + margin_bar.top + 50) 
            .text("Nation"); 

        // y-axis text
        annotations_lap.append("text")
            .attr("class", "y axis-label")
            .attr("text-anchor", "middle")
            .attr("x", -chartHeight_bar_lap / 2)
            .attr("y", margin_bar.left - 40)
            .attr("transform", "rotate(-90)")
            .text("Fastest Rate (%)");

        function updateBarsAnimatedLap(yearKey) {

            const data = yearKey;

            const genres_lap = d3.map(data, d => d.Nationality);
            const genreScale_lap = d3.scaleBand().domain(genres_lap).range([0, chartWidth_bar_lap]);

            // Update and animate axes
            bottomAxis_lap.scale(genreScale_lap)
            bottomAxisG_lap.transition().call(bottomAxis_lap);

            chartArea_lap.selectAll('rect.bar')
                .data(data)
                .join(enter => enter.append('rect')
                .attr('class', 'bar')
                .attr("fill", "#E10500")
                .attr("x", d => genreScale_lap(d.Nationality))
                .attr("y", d => percentScale_lap(d.FastLap_Rate)) // Start at bottom
                .attr("height", 0) // Grow up
                .attr("width", genreScale_lap.bandwidth())
                .call(enter => enter.transition()
                    .attr("y", d => percentScale_lap(d.FastLap_Rate))
                    .attr("height", d => percentScale_lap(0) - percentScale_lap(d.FastLap_Rate))),
            update => update.call(update => update.transition()
                .attr("x", d => genreScale_lap(d.Nationality))
                .attr("y", d => percentScale_lap(d.FastLap_Rate))
                .attr("height", d => percentScale_lap(0) - percentScale_lap(d.FastLap_Rate))
                .attr("width", genreScale_lap.bandwidth())),
            exit => exit.call(exit => exit.transition().attr('opacity', 0).remove())
        ); 
        };

        // Buttons and Interactivity
        const all_given_keys = Object.keys(myDictionary).sort()
        all_given_keys.forEach(d => {
            d3.select("div#buttons-bar")
                .append("button")
                .text(d)
                .on("click", function () {
                    updateBarsAnimated(myDictionary[d]);
                    updateBarsAnimatedYearActive(myDictionary[d]);
                    updateBarsAnimatedLap(myDictionary[d]);
                })
        })
        console.log(myDictionary);
        updateBarsAnimated(myDictionary["All Years"]);
        updateBarsAnimatedYearActive(myDictionary["All Years"]);
        updateBarsAnimatedLap(myDictionary["All Years"])
    };
    loadData();
</script>
</body>
</html>
