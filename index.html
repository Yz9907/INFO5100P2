<html>
<head>
    <meta charset="UTF-8">
    <title>Visualizing F1 Driver's Success Across Nations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
</head>

<body>
    <h3>Creating a Choropleth Map</h3>
    <svg id="choropleth" height="700" width="900" style="margin:20px"></svg>
    <svg id="legend" width="100" height="200" style="margin:20px"></svg>

    <script>
        //switching country codes to full country names to match world data
        const countryName = {
            "ITA": "Italy",
            "ARG": "Argentina",
            "GBR": "United Kingdom",
            "AUS": "Australia",
            "USA": "United States",
            "NZL": "New Zealand",
            "AUT": "Austria",
            "BRA": "Brazil",
            "RSA": "South Africa",
            "FIN": "Finland",
            "FRA": "France",
            "GER": "Germany",
            "ESP": "Spain",
            "CAN": "Canada",
            "NED": "Netherlands",
        };

        const svg = d3.select("#choropleth");
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        const projection = d3.geoMercator()
            .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        async function loadData() {

        const worldData = await d3.json("data/world_map.json");
        const championData = await d3.csv("data/df_champion_clean.csv", d3.autoType);

        //have to convert country codes to the full length names to get world_map geo values
        championData.forEach(d => {
            d.Nationality = countryName[d.Nationality] || d.Nationality; 
        });

        //adding all the champion points together per country
        const country_points = {};
        championData.forEach(d => {
            if (country_points[d.Nationality]) {
                country_points[d.Nationality] += d.Points;
            } else {
                country_points[d.Nationality] = d.Points;
            }
        });
        
        const pointsArray = Object.values(country_points);
        //figuring out the color scheme and what color scales.
        const colorScale = d3.scaleQuantile()
            .domain(pointsArray)
        //Will need to change these thresholds once data is segregated to every five years
            .range(["#D5D7E5", "#C4A5C4", "#9986AD", "#5B6887", "#46324F"]); //light to dark
        //color scale set: #514E79 #555A80 #5B6887 #696B94 #8178A0 #9986AD #AF95B9 #C4A5C4 #D0B4C9 
        //scale generated from here: https://hihayk.github.io/scale/#2/6/12/57/-21/-93/44/10/5B6887/184/28/242/white


        //adding countries but colored by total points

        svg.selectAll(".country")
            .data(worldData.features)
            .join("path")
            .attr("class", "country")
            .attr("d", path)
            .attr("stroke", "grey")
            .attr("stroke-width", .2)
            .attr("fill", d => {
                const countryName = d.properties.name_long;
                const points = country_points[countryName];
                return points !== undefined ? colorScale(points) : "#E0E0E0"; //any countries that have zeros are just light gray rather than getting compiled up
            });

        //legend - we should move to the side of graph I think or get rid of entirely cause of hover feature once implemented
        const legend = d3.select("#legend");
        const thresholds = [1].concat(colorScale.quantiles());  //placing 1 at the beginning so that countries with 0 points don't mistakingly get placed on legend

        colorScale.range().forEach((color, i) => {
            legend.append("rect")
                .attr("x", 10)
                .attr("y", i * 25)
                .attr("width", 20)
                .attr("height", 20)
                .attr("fill", color);

            const min = Math.round(thresholds[i]);
            const max = Math.round(thresholds[i + 1] || d3.max(pointsArray)); 
            legend.append("text")
                .attr("x", 40)
                .attr("y", i * 25 + 15)
                .text(`${min} - ${max}`);
            });


        };

    loadData();
</script>
</body>
</html>